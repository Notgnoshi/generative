# Generative Art

[![GitHub Actions status](https://github.com/Notgnoshi/generative/workflows/Tests/badge.svg)](https://github.com/Notgnoshi/generative/actions)
[![GitHub Actions status](https://github.com/Notgnoshi/generative/workflows/Pylint/badge.svg)](https://github.com/Notgnoshi/generative/actions)
[![GitHub Actions status](https://github.com/Notgnoshi/generative/workflows/Black/badge.svg)](https://github.com/Notgnoshi/generative/actions)
[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)

A polyglot collection of composable generative art tools, with a focus on 2D computational geometry.

# Table of contents

# How to build
This project contains a mix of Rust, C++, and Python. It's primarily Rust.

Install dependencies with
```sh
# Python dependencies
python3 -m venv --prompt generative .venv
source .venv/bin/activate
python3 -m pip install -r requirements.txt
# C++ dependencies
sudo apt install build-essential cmake ninja-build
git submodule update --init --recursive
```

The Rust build has been configured to also perform the C++ CMake build, so all you need is
```sh
cargo build
```

If you don't want to build the C++ parts, you can do
```sh
cargo build --no-default-features
```
but note that this will disable building the [`geom2graph`](#geom2graph) tool.

You can run the Python tests with
```sh
source .venv/bin/activate
pytest
```
and the Rust tests with
```sh
cargo test
```
If the C++ tests have been enabled with `--all-features`, or `--features=cxx-tests`, they are copied
to `target/debug/cxx-tests`.

# Philosophy

There is a [`generative`](./generative/) Rust/C++/Python library, but the user is expected to use
the [CLI tools](./tools/) instead. I'm enamored with the Unix philosophy, so each tool does its best
to produce/consume a standard textual interface.
* Each tool read/writes to/from `stdin`/`stdout`
* Logging is done to `stderr`
* Geometries are in [WKT](https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry)
  format, one geometry per line
* Graphs are in [TGF](https://en.wikipedia.org/wiki/Trivial_Graph_Format) format

# Examples
## Asemic writing
The following snippet generates random asemic writing glyphs
```sh
glyphs() {
    local glyph_kind="$1"
    local number="$2"
    local size="$3"

    {
        for _ in $(seq "$number"); do
            $glyph_kind "$size"
        done
    } | pack --width 1000 --height 1000 --padding 20
}
```

To generate random glyphs, we'll:
1. Take a geometry graph
2. Perform random traverals of the graph
3. (optionally) Smooth each traversal into a curve
```sh
random_rounded() {
    local size="$1"
    point-cloud --log-level WARN --domain unit-square --points 15 --scale 6 |
        urquhart --output-format tgf |
        traverse --log-level WARN --traversals 5 --length 5 --untraversed |
        transform --scale="$size" |
        smooth --iterations 4 |
        bundle
}
glyphs random_rounded 90 10 | wkt2svg --output $ASEMIC_RANDOM_ROUNDED
```
![](./examples/asemic/random-rounded.svg)
The `--untraversed` points could be replaced with diacritical marks.

We could also use the triangulation of a random point cloud
```sh
random_triangulated() {
    local size="$1"
    point-cloud --log-level WARN --domain unit-square --points 10 --scale 6 |
        triangulate --output-format tgf |
        traverse --log-level WARN --traversals 3 --length 3 --remove-after-traverse |
        transform --scale="$size" |
        smooth --iterations 4 |
        bundle
}
glyphs random_triangulated 100 10 | wkt2svg --output $ASEMIC_RANDOM_TRIANGULATED
```
![](./examples/asemic/random-triangulated.svg)

Neither of these approaches give a coherent sense of self-similarity that's necessary for linguistic
glyphs. If, instead of using a random point cloud, we use a regular grid, that dramatically changes
the sense of self-similarity.
```sh
grid_rounded() {
    local size="$1"
    grid --output-format graph --width=2 --height=3 |
        traverse --log-level WARN --traversals 5 --length 5 --remove-after-traverse |
        transform --scale="$size" |
        smooth --iterations 4 |
        bundle
}
glyphs grid_rounded 120 20 | wkt2svg --output $ASEMIC_GRID_ROUNDED
```
![](./examples/asemic/grid-rounded.svg)

We can also reduce the number of smoothing iterations to get beveled corners
```sh
grid_beveled() {
    local size="$1"
    grid --output-format graph --width=2 --height=3 |
        traverse --log-level WARN --traversals 5 --length 5 --remove-after-traverse |
        transform --scale="$size" |
        smooth --iterations 1 |
        bundle
}
glyphs grid_beveled 120 20 | wkt2svg --output $ASEMIC_GRID_BEVELED
```
![](./examples/asemic/grid-beveled.svg)

We could also regular triangle grid, to get loopier results, with no vertical lines
```sh
grid_triangulated() {
    local size="$1"
    grid --grid-type triangle --output-format graph --width=2 --height=3 |
        traverse --log-level WARN --traversals 4 --length 5 --remove-after-traverse |
        transform --scale="$size" |
        smooth --iterations 4 |
        bundle
}
glyphs grid_triangulated 100 20 | wkt2svg --output $ASEMIC_GRID_TRIANGULATED
```
![](./examples/asemic/grid-triangulated.svg)

```sh
grid_jagged() {
    local size="$1"
    grid --grid-type ragged --output-format graph --width=2 --height=3 |
        traverse --log-level WARN --traversals 4 --length 5 --remove-after-traverse |
        transform --scale="$size" |
        smooth --iterations 4 |
        bundle
}
glyphs grid_jagged 100 20 | wkt2svg --output $ASEMIC_GRID_JAGGED
```
![](./examples/asemic/grid-jagged.svg)

## Random L-Systems
[examples/random-lsystems/saved.json](examples/random-lsystems/saved.json) contains parameters for
randomly (pre)generated Lindenmayer systems.
```sh
@RANDOM_LSYSTEMS_SNIPPET@
```
@RANDOM_LSYSTEM_IMAGES@

# The tools

## Utilities
### wkt2svg
### render.py
### bundle
### pack
### format.py

## Lindenmayer Systems
### random-production-rules.py
### parse-production-rules.py
### interpret-lstring.py
### random-lsystem.sh

## Transformations
### project.py
### geom2graph
### smooth
### snap
### transform

## Generation
### point-cloud
### grid

## Algorithms
### bitwise
### dla
### streamline
### traverse
### triangulate
### urquhart
